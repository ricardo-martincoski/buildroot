#!/usr/bin/env bash
# Please test this script using test/support/download/git

# We want to catch any unexpected failure, and exit immediately
set -e

# Download helper for git, to be called from the download wrapper script
#
# Call it as:
#   .../git [-q] [-r] OUT_FILE REPO_URL CSET BASENAME
#
#   -q  Be quiet.
#   -r  Clone and archive sub-modules.
#
# Environment:
#   GIT      : the git command to call

verbose=
recurse=0
while getopts :qr OPT; do
    case "${OPT}" in
    q)  verbose=-q; exec >/dev/null;;
    r)  recurse=1;;
    \?) printf "unknown option '%s'\n" "${OPTARG}" >&2; exit 1;;
    esac
done
shift $((OPTIND-1))

output="${1}"
repo="${2}"
cset="${3}"
basename="${4}"

shift 4 # Get rid of our options

# Caller needs to single-quote its arguments to prevent them from
# being expanded a second time (in case there are spaces in them)
_git() {
    eval ${GIT} "${@}"
}

_git init ${verbose} "'${basename}'"

pushd "${basename}" >/dev/null

# Save temporary files inside the .git directory that will be deleted after the
# checkout is done.
a_r=".git/all_refs"
c_r=".git/candidate_refs"
m_r=".git/matching_refs"

# Ask the server the list of all refs that can use the most optimized download
# (git fetch --depth 1). In the case the remote gets updated between this
# command and the git fetch, fall back to a full fetch.
_git ls-remote "'${repo}'" >${a_r}

# Do a strict filtering before hand, so we can use less strict checking to
# determine a cset can use the optimized download. This way, refs with funny
# names (e.g. 'bra{2}nch', 'tag$$') will simply fall back to a full fetch.
if grep -F "${cset}" ${a_r} >${c_r} 2>/dev/null; then
    if grep -E "\<(|(|refs/)(heads|tags)/)${cset}$" ${c_r} >${m_r} 2>/dev/null; then
        # Support branches and tags in the simplified form.
        # Support branches and tags and special refs in the form refs/tags/tag.
        # NOTE: When using an ancient git client, the fetch of a tag in the
        # simplified form fails and would fall back to a full fetch. Git version
        # 1.7.1 (RHEL6) fails, 1.8.2.3 (RHEL5+EPEL) succeeds. Instead of using
        # the received ${cset} as ref, always use the complete form.
        # When the name is ambiguous (there is a branch and a tag with the same
        # name), the branch is selected. This way we behave like git fetch, git
        # clone and git checkout. To accomplish this we use the first match
        # because output of git ls-remote is already sorted by ref.
        ref="$(cut -f 2 ${m_r} | head -1)"
    elif grep "^${cset}\>" ${c_r} >${m_r} 2>/dev/null; then
        # Support sha1 of branch head and commit pointed by tag (annotated or
        # not) and sha1 of special refs head.
        # Do not support partial sha1 because it is possible it is unambiguous
        # in the subset of ls-remote but ambiguous in the full set of all sha1.
        # A sha1 can be referenced by many names. Any reference can be used but
        # avoid using HEAD if possible because it is the most volatile one.
        # HEAD appears at the begin of ls-remote, so use the last match.
        ref="$(cut -f 2 ${m_r} | tail -1)"
        # The ref of the sha1 pointed by an annotated tag ends with tag^{} in
        # the output of git ls-remote but we want the name of the tag to fetch.
        ref=${ref/%"^{}"}
    fi
fi
git_done=0
if [ "${ref}" ]; then
    printf "Doing shallow fetch, using '%s' to get '%s'\n" "${ref}" "${cset}"
    # Because ${ref} is always in the complete form we don't need to create a
    # separate namespace (i.e. refs/buildroot/) and just use the ref as is.
    if _git fetch -u ${verbose} "${@}" --depth 1 "'${repo}'" \
                  "'+${ref}:${ref}'" 2>&1; then
        unshallow=--unshallow
        if _git checkout -q "'${cset}'" 2>&1; then
            git_done=1
        else
            # It catches the case we want a sha1 but the remote changed the ref
            # after git ls-remote.
            printf "Checkout failed, falling back to doing a full fetch\n"
        fi
    else
        # It catches the case the remote supports only dumb http transport.
        # It catches the case the remote removed the ref after git ls-remote.
        printf "Shallow fetch failed, falling back to doing a full fetch\n"
    fi
fi
if [ ${git_done} -eq 0 ]; then
    printf "Doing full fetch\n"
    # Fetch all branch and tag refs. The same as git clone.
    _git fetch -u ${verbose} "${@}" ${unshallow} "'${repo}'" \
               "'+refs/tags/*:refs/tags/*'" "'+refs/heads/*:refs/heads/*'"
    if _git checkout -q "'${cset}'" 2>&1; then
        git_done=1
    fi
fi
if [ ${git_done} -eq 0 ]; then
    printf "Doing mirror fetch\n"
    # Fetch all refs, including special refs. The same as git clone --mirror.
    _git fetch -u ${verbose} "${@}" ${unshallow} "'${repo}'" "'+refs/*:refs/*'"
    _git checkout -q "'${cset}'"
fi

# Get date of commit to generate a reproducible archive.
# %cD is RFC2822, so it's fully qualified, with TZ and all.
date="$( _git log -1 --pretty=format:%cD )"
du -s -h .git/objects

# There might be submodules, so fetch them.
if [ ${recurse} -eq 1 ]; then
    _git submodule update --init --recursive
fi

# Log the sha1. It can be used for automated tests and debug.
if [ -z ${verbose} ]; then
    sha1=$(_git rev-parse HEAD)
    printf "Checked out '%s'.\n" "${sha1}"
fi

# We do not need the .git dir; we keep other .git files, in case they
# are the only files in their directory.
rm -rf .git

popd >/dev/null

# Generate the archive, sort with the C locale so that it is reproducible
find "${basename}" -not -type d >"${basename}.list"
LC_ALL=C sort <"${basename}.list" >"${basename}.list.sorted"
tar cf - --numeric-owner --owner=0 --group=0 --mtime="${date}" \
         -T "${basename}.list.sorted" >"${output}.tar"
gzip -n <"${output}.tar" >"${output}"
